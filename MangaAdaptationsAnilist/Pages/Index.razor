@page "/"
@implements IDisposable
@using MangaAdaptationsAnilist.Data
@using MangaAdaptationsAnilist.GraphQl
@using GraphQL.Client.Http
@using MangaAdaptationsAnilist.Data
@using MangaAdaptationsAnilist.Data.Model
@using MangaAdaptationsAnilist.Shared
@using Microsoft.AspNetCore.Components.Routing
@using Microsoft.JSInterop
@using MediaList = MangaAdaptationsAnilist.Data.MediaList
@inject Blazored.SessionStorage.ISessionStorageService _sessionStorage
@inject IJSRuntime _js;
@inject NavigationManager _navigationManager;

@if (PageState == PageStates.Input)
{
    <div class="mb-3">
        <QueryForm OnSubmit="@DoSearch"/>
    </div>
}
@if (PageState == PageStates.Loading)
{
    <div class="text-center mb-3">
        @_progressText
    </div>
    <div class="progress">
        <div class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar"
             aria-valuenow="100" aria-valuemin="0" aria-valuemax="100" style="width: 100%"></div>
    </div>
}
@if (PageState == PageStates.Results)
{
    <ResultLayout Items="@_resultItems" ItemsPerPage="@ItemsPerPage"/>
}
@if (PageState == PageStates.Error)
{ 
    <h4 class="text-center">An error occurred</h4>
    <p>@((MarkupString)_errorText)</p>
    <div>
        <button class="btn btn-outline-secondary" @onclick="StartOver" type="button">Back</button>
    </div>
}

@code
{
    enum PageStates
    {
        Input,
        Loading,
        Results,
        Error
    }

    [CascadingParameter]
    public MainLayout Layout { get; set; }

    private int ItemsPerPage { get; set; } = 100;
        
    private const string Title = "MangaAdaptations for AniList";
    
    private PageStates _pageState = PageStates.Input;
    private PageStates PageState
    {
        get => _pageState;
        set
        {
            _pageState = value;
            switch (_pageState)
            {
                case PageStates.Error:
                case PageStates.Results:
                    Layout.IsBackButtonVisible = true;
                    
                    break;
                default:
                    Layout.IsBackButtonVisible = false;
                    break;
            }
            StateHasChanged();
        }
    }

    private string _progressText = "";
    private string _errorText = "";

    private MangaWithAnime[] _resultItems = [];

    protected override Task OnInitializedAsync()
    {
        _navigationManager.LocationChanged += OnLocationChanged;
        Layout.Title = Title;
        Layout.StartOverCallback = () =>
        {
            _navigationManager.NavigateTo("/");
            StartOver();
        };
        return base.OnInitializedAsync();
    }

    private async void OnLocationChanged(object? sender, LocationChangedEventArgs e)
    {
        var uri = _navigationManager.ToBaseRelativePath(e.Location);
        if (uri == string.Empty)
        {
            StartOver();
        }
        else if (uri.StartsWith("#results"))
        {
            if(PageState is PageStates.Input)
            {
                if (!await LoadResultsFromCacheAsync())
                {
                    // No cached data available
                    _navigationManager.NavigateTo("/");
                    StartOver();
                }
            }

        }
    }
    
    void IDisposable.Dispose()
    {
        // Unsubscribe from the event when our component is disposed
        _navigationManager.LocationChanged -= OnLocationChanged;
    }
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        var hash = await _js.InvokeAsync<string>("getUrlHash");
        if (hash == "#results" && firstRender)
        {
            // Page has been reloaded; try to restore data from cache
            if (!await LoadResultsFromCacheAsync())
            {
                // No cached data available
                _navigationManager.NavigateTo("/");
                return;
            }
        }
        await base.OnAfterRenderAsync(firstRender);
    }
    
    void StartOver()
    {
        Layout.Title = Title;
        PageState = PageStates.Input;
        StateHasChanged();
    }
    
    async void DoSearch(QueryModel queryModel)
    {
        ItemsPerPage = queryModel.ResultsPerPage;
        PageState = PageStates.Loading;
        _progressText = "Retrieving content from AniList...";
        StateHasChanged();
        AniListResponse[] query;
        
        try
        {
            query = await AniListClient.ExecuteQuery(queryModel.UserName, 
                queryModel.GetStatuses().Cast<MediaListStatus?>().ToArray(),
                (currentPage, lastPage) =>
                {
                    _progressText = $"Retrieving content from AniList... (page {currentPage.ToString()})";
                    StateHasChanged();
                });
        }
        catch (GraphQlException ex)
        {
            _errorText = "GraphQl API error<p/>";

            foreach (var error in ex.Errors)
            {
                _errorText += $"<code>{error.Message}</code><p/>";
            }
            PageState = PageStates.Error;
            StateHasChanged();
            return;
        }
        catch (GraphQLHttpRequestException ex)
        {
            _errorText = $"This user's list is inaccessible. Please make sure that your manga list is set to public. AniList returned an internal server error:<br/><code>{ex.Content}</code>";
            PageState = PageStates.Error;
            StateHasChanged();
            return;
        }

        if (query.Length < 1)
        {
            _errorText = "No matches found. Either the list of the specified user is inaccessible or there are currently no anime adaptations for you available.";
            PageState = PageStates.Error;
            StateHasChanged();
            return;
        }
        
        _progressText = $"Processing list...";
        StateHasChanged();

        var titles = new Dictionary<long /* RecommendationId */, Tuple<MediaItem /* Recommendation */, List<MediaItem> /* Origins */>>();
        var library = new List<long /* MediaId*/>();

        foreach (var response in query)
        {
            foreach (var mediaListPart in response.Page?.MediaList ?? [])
            {
                var media = mediaListPart.Media;
                if (media == null)
                {
                    continue;
                }
                
                if ((media.Relations?.Nodes?.Count ?? 0) <= 0)
                {
                    // Empty nodes
                    continue;
                }
                
                foreach (var node in media.Relations?.Nodes ?? [])
                {
                    if (node is not { Type: MediaType.Anime })
                    {
                        continue;
                    }
         
                    // Enumerate tags
                    var tags = new string[node.Tags.Count];
                    var tcnt = 0;
                    foreach(var tag in node.Tags)
                    {
                        tags[tcnt] = tag.Name;
                        tcnt++;
                    }
                    
                    // Check for excluded tags
                    var excluded = false;
                    foreach (var genre in queryModel.GetExcludedTags())
                    {
                        if (node.Genres.Contains(genre, StringComparer.InvariantCultureIgnoreCase) || 
                            tags.Contains(genre, StringComparer.InvariantCultureIgnoreCase))
                        {
                            excluded = true;
                        }
                    }
                    if (excluded)
                    {
                        continue;
                    }
                    
                    // Check for requested tags
                    var notMatched = false;
                    foreach (var genre in queryModel.GetFilterTags())
                    {
                        if (!node.Genres.Contains(genre, StringComparer.InvariantCultureIgnoreCase) && 
                            !tags.Contains(genre, StringComparer.InvariantCultureIgnoreCase))
                        {
                            notMatched = true;
                        }
                    }

                    if (notMatched)
                    {
                        continue;
                    }

                    // Add each anime relation of current title
                    var mangaId = media.Id;
                    if (!titles.ContainsKey(mangaId))
                    {
                        // Supplement the manga as an MediaItem if not yet added
                        titles[mangaId] =
                            new Tuple<MediaItem, List<MediaItem>>(new MediaItem(media), []);
                    }
                    // Append the anime adaptation to the existing item
                    titles[mangaId].Item2.Add(new MediaItem(node));
                }
            }
        }
        
        // Translate dictionary into MangaWithAnime[] 
        var resultList = new List<MangaWithAnime>();
        foreach (var (manga, animeRelations) in titles.Values)
        {
            if (animeRelations.Count < 1)
            {
                continue;
            }

            foreach (var animeRelation in animeRelations)
            {  
                resultList.Add(new MangaWithAnime
                {
                    Anime = animeRelation,
                    OriginManga = manga
                });
            }
        }

        var results = resultList.ToArray();
        
        // Sort results
        switch (queryModel.SortBy)
        {
            case SortingMode.AlphabeticalAsc:
                Array.Sort(results, (x, y) => String.Compare(x.Anime.Title, y.Anime.Title, StringComparison.InvariantCulture));
                break;
            case SortingMode.AlphabeticalDesc:
                Array.Sort(results, (x, y) => String.Compare(y.Anime.Title, x.Anime.Title, StringComparison.InvariantCulture));
                break;
            case SortingMode.PublicRatingsDesc:
                Array.Sort(results, (x, y) => y.Anime.AverageScore.CompareTo(x.Anime.AverageScore));
                break;
        }
        
        // Cache results
        var task = _sessionStorage.SetItemAsync("results", results);
        
        _navigationManager.NavigateTo("#results");
        LoadResults(results);
        await task;
    }

    void LoadResults(MangaWithAnime[] results)
    {
        if (results.Length < 1)
        {
            _errorText = "No matches found. There are currently no anime adaptations available. Please check the filter settings and try again.";
            PageState = PageStates.Error;
            StateHasChanged();
            return;
        }

        _resultItems = results;
        PageState = PageStates.Results;
        _progressText = $"Done";
        
        Layout.Title = "Your Results";
        StateHasChanged();
    }

    async Task<bool> LoadResultsFromCacheAsync()
    {
        if (!await _sessionStorage.ContainKeyAsync("results"))
            return false;

        PageState = PageStates.Loading;
        _progressText = "Restoring list from cache...";
        StateHasChanged();

        await Task.Delay(100);

        var results = await _sessionStorage.GetItemAsync<MangaWithAnime[]>("results");

        if (results == null || results.Length < 1)
        {
            return false;
        }
        LoadResults(results);

        return true;
    }
}